{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/data-model.js","src/domain/edge.js","src/domain/index.js","src/domain/node/chance-node.js","src/domain/node/decision-node.js","src/domain/node/node.js","src/domain/node/terminal-node.js","src/domain/object-with-computed-values.js","src/domain/object-with-id-and-editable-fields.js","src/domain/point.js","src/domain/text.js","src/index.js","src/validation-result.js","index.js"],"names":["require","e","t","n","r","s","o","u","a","i","f","Error","code","l","exports","call","length","1","module","_sdUtils","domain","_interopRequireWildcard","_validationResult","DataModel","data","nodes","edges","texts","payoffNames","defaultCriterion1Weight","weightLowerBound","weightUpperBound","Infinity","expressionScope","$codeError","$codeDirty","$version","validationResults","maxStackSize","undoStack","redoStack","undoRedoStateChangedCallback","nodeAddedCallback","nodeRemovedCallback","textAddedCallback","textRemovedCallback","callbacksDisabled","load","filterLocation","arguments","undefined","filterComputed","replacer","filterPrivate","k","v","Utils","startsWith","stringify","this","getRoots","slice","getJsonReplacer","clear","trees","forEach","nodeData","_this","createNodeFromData","textData","location","Point","x","y","text","Text","value","push","clearExpressionScope","extend","serialize","dto","dataReviver","JSON","parse","serializedData","ValidationResult","createFromDTO","dataModel","warn","byId","$id","loadComputedValues","computed","filterFunction","res","forOwn","key","isFunction","parent","node","DecisionNode","$TYPE","type","ChanceNode","TerminalNode","$fieldStatus","name","folded","edgeOrNode","addNode","childEdges","ed","edge","_this3","childNode","isArray","payoff","probability","self","_addChild","_fireNodeAddedCallback","parentNode","child","$parent","Edge","_setEdgeInitialProbability","$l","removeNode","_removeNode","parentEdge","find","removeEdge","_removeEdge","_fireNodeRemovedCallback","findSubtreeRoots","_this4","typeToConvertTo","newNode","createNodeByType","replaceNode","_this5","oldNode","index","indexOf","filter","nodeToCopy","cloneComputedValues","clone","cloneNode","childClone","cloneSubtree","guid","cloneDeep","nodeToAttach","nodeOrEdge","getAllDescendantEdges","id","findNodeById","findEdgeById","splice","nodesToRemove","edgesToRemove","result","apply","_toConsumableArray","getAllDescendantNodes","descendants","unshift","revertConf","state","_pushToStack","_fireUndoRedoCallback","saveStateFromSnapshot","createStateSnapshot","newState","pop","_setNewState","clearComputedValues","_fireTextAddedCallback","_this6","removeText","_fireTextRemovedCallback","_this7","reverse","redo","nodeById","getObjectByIdMap","edgeById","onUndo","onRedo","stack","obj","shift","_objectWithComputedValues","_ObjectWithComputedVa","$DISPLAY_VALUE_NAMES","val","computedValue","displayValue","Object","keys","_node","_decisionNode","_chanceNode","_terminalNode","_edge","_point","_text","_Node","Node","withChildren","dx","dy","move","moveTo","_objectWithIdAndEditableFields","ObjectWithComputedValues","_ObjectWithIdAndEdita","_temp","_possibleConstructorReturn","_ret","ruleName","fieldPath","path","get","set","ObjectWithIdAndEditableFields","valid","getFieldStatus","syntax","fieldStatus","Array","_dataModel","errors","warnings","objectIdToError","error","isString","errorsByName","objE","getOwnPropertyNames","_index"],"mappings":"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","file":"sd-model.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","import {Utils, log} from \"sd-utils\";\nimport * as domain from \"./domain\";\nimport {ValidationResult} from \"./validation-result\";\n\n/*\n * Data model manager\n * */\nexport class DataModel {\n\n    nodes = [];\n    edges = [];\n\n    texts = []; //floating texts\n    payoffNames = [];\n    defaultCriterion1Weight = 1;\n    weightLowerBound = 0;\n    weightUpperBound = Infinity;\n\n\n    expressionScope = {}; //global expression scope\n    code = \"\";//global expression code\n    $codeError = null; //code evaluation errors\n    $codeDirty = false; // is code changed without reevaluation?\n    $version=1;\n\n    validationResults = [];\n\n    // undo / redo\n    maxStackSize = 20;\n    undoStack = [];\n    redoStack = [];\n    undoRedoStateChangedCallback = null;\n    nodeAddedCallback = null;\n    nodeRemovedCallback = null;\n\n    textAddedCallback = null;\n    textRemovedCallback = null;\n\n    callbacksDisabled = false;\n\n    constructor(data) {\n        if(data){\n            this.load(data);\n        }\n    }\n\n    getJsonReplacer(filterLocation=false, filterComputed=false, replacer, filterPrivate =true){\n        return function (k, v) {\n\n            if ((filterPrivate && Utils.startsWith(k, '$')) || k == 'parentNode') {\n                return undefined;\n            }\n            if (filterLocation && k == 'location') {\n                return undefined;\n            }\n            if (filterComputed && k == 'computed') {\n                return undefined;\n            }\n\n            if (replacer){\n                return replacer(k, v);\n            }\n\n            return v;\n        }\n    }\n\n    serialize(stringify=true, filterLocation=false, filterComputed=false, replacer, filterPrivate =true){\n        var data =  {\n            code: this.code,\n            expressionScope: this.expressionScope,\n            trees: this.getRoots(),\n            texts: this.texts,\n            payoffNames: this.payoffNames.slice(),\n            defaultCriterion1Weight: this.defaultCriterion1Weight,\n            weightLowerBound: this.weightLowerBound,\n            weightUpperBound: this.weightUpperBound\n        };\n\n        if(!stringify){\n            return data;\n        }\n\n        return Utils.stringify(data, this.getJsonReplacer(filterLocation, filterComputed, replacer, filterPrivate), []);\n    }\n\n\n    /*Loads serialized data*/\n    load(data) {\n        //roots, texts, code, expressionScope\n        var callbacksDisabled = this.callbacksDisabled;\n        this.callbacksDisabled = true;\n\n        this.clear();\n\n\n        data.trees.forEach(nodeData=> {\n            var node = this.createNodeFromData(nodeData);\n        });\n\n        if (data.texts) {\n            data.texts.forEach(textData=> {\n                var location = new domain.Point(textData.location.x, textData.location.y);\n                var text = new domain.Text(location, textData.value);\n                this.texts.push(text);\n            })\n        }\n\n        this.clearExpressionScope();\n        this.code = data.code || '';\n\n        if (data.expressionScope) {\n            Utils.extend(this.expressionScope, data.expressionScope);\n        }\n\n        if (data.payoffNames !== undefined && data.payoffNames !== null) {\n            this.payoffNames = data.payoffNames;\n        }\n\n        if (data.defaultCriterion1Weight !== undefined && data.defaultCriterion1Weight !== null) {\n            this.defaultCriterion1Weight = data.defaultCriterion1Weight;\n        }\n\n        if (data.weightLowerBound !== undefined && data.weightLowerBound !== null) {\n            this.weightLowerBound = data.weightLowerBound;\n        }\n\n        if (data.weightUpperBound !== undefined && data.weightUpperBound !== null) {\n            this.weightUpperBound = data.weightUpperBound;\n        }\n\n\n        this.callbacksDisabled = callbacksDisabled;\n    }\n\n    getDTO(filterLocation=false, filterComputed=false, filterPrivate =false){\n        var dto = {\n            serializedData: this.serialize(true, filterLocation, filterComputed, null, filterPrivate),\n            $codeError: this.$codeError,\n            $codeDirty: this.$codeDirty,\n            validationResults: this.validationResults.slice()\n\n        };\n        return dto\n    }\n\n    loadFromDTO(dto, dataReviver){\n        this.load(JSON.parse(dto.serializedData, dataReviver));\n        this.$codeError = dto.$codeError;\n        this.$codeDirty = dto.$codeDirty;\n        this.validationResults.length=0;\n        dto.validationResults.forEach(v=>{\n            this.validationResults.push(ValidationResult.createFromDTO(v))\n        })\n    }\n\n    /*This method updates only computation results/validation*/\n    updateFrom(dataModel){\n        if(this.$version>dataModel.$version){\n            log.warn(\"DataModel.updateFrom: version of current model greater than update\")\n            return;\n        }\n        var byId = {}\n        dataModel.nodes.forEach(n=>{\n            byId[n.$id] = n;\n        });\n        this.nodes.forEach((n,i)=>{\n            if(byId[n.$id]){\n                n.loadComputedValues(byId[n.$id].computed);\n            }\n        });\n        dataModel.edges.forEach(e=>{\n            byId[e.$id] = e;\n        });\n        this.edges.forEach((e,i)=>{\n            if(byId[e.$id]){\n                e.loadComputedValues(byId[e.$id].computed);\n            }\n        });\n        this.expressionScope = dataModel.expressionScope;\n        this.$codeError = dataModel.$codeError;\n        this.$codeDirty = dataModel.$codeDirty;\n        this.validationResults  = dataModel.validationResults;\n    }\n\n    getGlobalVariableNames(filterFunction = true){\n        var res = [];\n        Utils.forOwn(this.expressionScope, (value, key)=>{\n            if(filterFunction && Utils.isFunction(value)){\n                return;\n            }\n            res.push(key);\n        });\n        return res;\n    }\n\n    /*create node from serialized data*/\n    createNodeFromData(data, parent) {\n        var node, location;\n\n        if(data.location){\n            location = new domain.Point(data.location.x, data.location.y);\n        }else{\n            location = new domain.Point(0,0);\n        }\n\n        if (domain.DecisionNode.$TYPE == data.type) {\n            node = new domain.DecisionNode(location);\n        } else if (domain.ChanceNode.$TYPE == data.type) {\n            node = new domain.ChanceNode(location);\n        } else if (domain.TerminalNode.$TYPE == data.type) {\n            node = new domain.TerminalNode(location);\n        }\n        if(data.$id){\n            node.$id = data.$id;\n        }\n        if(data.$fieldStatus){\n            node.$fieldStatus = data.$fieldStatus;\n        }\n        node.name = data.name;\n\n        if(data.code){\n            node.code = data.code;\n        }\n        if (data.expressionScope) {\n            node.expressionScope = data.expressionScope\n        }\n        if(data.computed){\n            node.loadComputedValues(data.computed);\n        }\n\n        node.folded = !!data.folded;\n\n        var edgeOrNode = this.addNode(node, parent);\n        data.childEdges.forEach(ed=> {\n            var edge = this.createNodeFromData(ed.childNode, node);\n            if(Utils.isArray(ed.payoff)){\n                edge.payoff = ed.payoff;\n            }else{\n                edge.payoff = [ed.payoff, 0];\n            }\n\n            edge.probability = ed.probability;\n            edge.name = ed.name;\n            if(ed.computed){\n                edge.loadComputedValues(ed.computed);\n            }\n            if(ed.$id){\n                edge.$id = ed.$id;\n            }\n            if(ed.$fieldStatus){\n                edge.$fieldStatus = ed.$fieldStatus;\n            }\n        });\n\n        return edgeOrNode;\n    }\n\n    /*returns node or edge from parent to this node*/\n    addNode(node, parent) {\n        var self = this;\n        self.nodes.push(node);\n        if (parent) {\n            var edge = self._addChild(parent, node);\n            this._fireNodeAddedCallback(node);\n            return edge;\n        }\n\n        this._fireNodeAddedCallback(node);\n        return node;\n    }\n\n    /*injects given node into given edge*/\n    injectNode(node, edge) {\n        var parent = edge.parentNode;\n        var child = edge.childNode;\n        this.nodes.push(node);\n        node.$parent = parent;\n        edge.childNode = node;\n        this._addChild(node, child);\n        this._fireNodeAddedCallback(node);\n    }\n\n    _addChild(parent, child) {\n        var self = this;\n        var edge = new domain.Edge(parent, child);\n        self._setEdgeInitialProbability(edge);\n        self.edges.push(edge);\n\n        parent.childEdges.push(edge);\n        child.$parent = parent;\n        return edge;\n    }\n\n    _setEdgeInitialProbability(edge) {\n        if (edge.parentNode instanceof domain.ChanceNode) {\n            edge.probability = '#';\n        } else {\n            edge.probability = undefined;\n        }\n\n    }\n\n    /*removes given node and its subtree*/\n    removeNode(node, $l = 0) {\n\n        var self = this;\n        node.childEdges.forEach(e=>self.removeNode(e.childNode, $l + 1));\n\n        self._removeNode(node);\n        var parent = node.$parent;\n        if (parent) {\n            var parentEdge = Utils.find(parent.childEdges, (e, i)=> e.childNode === node);\n            if ($l == 0) {\n                self.removeEdge(parentEdge);\n            } else {\n                self._removeEdge(parentEdge);\n            }\n        }\n        this._fireNodeRemovedCallback(node);\n    }\n\n    /*removes given nodes and their subtrees*/\n    removeNodes(nodes) {\n\n        var roots = this.findSubtreeRoots(nodes);\n        roots.forEach(n=>this.removeNode(n, 0), this);\n    }\n\n    convertNode(node, typeToConvertTo){\n        var newNode;\n        if(!node.childEdges.length && node.$parent){\n            newNode = this.createNodeByType(typeToConvertTo, node.location);\n        }else{\n            if(node instanceof domain.DecisionNode && typeToConvertTo==domain.ChanceNode.$TYPE){\n                newNode = this.createNodeByType(typeToConvertTo, node.location);\n            }else if(typeToConvertTo==domain.DecisionNode.$TYPE){\n                newNode = this.createNodeByType(typeToConvertTo, node.location);\n            }\n        }\n\n        if(newNode){\n            newNode.name=node.name;\n            this.replaceNode(newNode, node);\n            newNode.childEdges.forEach(e=>this._setEdgeInitialProbability(e));\n            this._fireNodeAddedCallback(newNode);\n        }\n\n    }\n\n    createNodeByType(type, location){\n        if(type==domain.DecisionNode.$TYPE){\n            return new domain.DecisionNode(location)\n        }else if(type==domain.ChanceNode.$TYPE){\n            return new domain.ChanceNode(location)\n        }else if(type==domain.TerminalNode.$TYPE){\n            return new domain.TerminalNode(location)\n        }\n    }\n\n    replaceNode(newNode, oldNode){\n        var parent = oldNode.$parent;\n        newNode.$parent = parent;\n\n        if(parent){\n            var parentEdge = Utils.find(newNode.$parent.childEdges, e=>e.childNode===oldNode);\n            parentEdge.childNode = newNode;\n        }\n\n        newNode.childEdges = oldNode.childEdges;\n        newNode.childEdges.forEach(e=>e.parentNode=newNode);\n\n        var index = this.nodes.indexOf(oldNode);\n        if(~index){\n            this.nodes[index]=newNode;\n        }\n    }\n\n    getRoots() {\n        return this.nodes.filter(n=>!n.$parent);\n    }\n\n    findSubtreeRoots(nodes) {\n        return nodes.filter(n=>!n.$parent || nodes.indexOf(n.$parent) === -1);\n    }\n\n    /*creates detached clone of given node*/\n    cloneSubtree(nodeToCopy, cloneComputedValues) {\n        var self = this;\n        var clone = this.cloneNode(nodeToCopy);\n\n        nodeToCopy.childEdges.forEach(e=> {\n            var childClone = self.cloneSubtree(e.childNode, cloneComputedValues);\n            childClone.$parent = clone;\n            var edge = Utils.clone(e);\n            edge.$id = Utils.guid();\n            edge.parentNode = clone;\n            edge.childNode = childClone;\n            edge.payoff = Utils.cloneDeep(e.payoff);\n            edge.computed = {};\n            if (cloneComputedValues) {\n                edge.computed = Utils.cloneDeep(e.computed);\n                childClone.computed = Utils.cloneDeep(e.childNode.computed)\n            }\n            clone.childEdges.push(edge);\n        });\n        if (cloneComputedValues) {\n            clone.computed = Utils.cloneDeep(nodeToCopy.computed)\n        }\n        return clone;\n    }\n\n    /*attaches detached subtree to given parent*/\n    attachSubtree(nodeToAttach, parent) {\n        var self = this;\n        var nodeOrEdge = self.addNode(nodeToAttach, parent);\n\n        nodeToAttach.expressionScope = null;\n\n        var childEdges = self.getAllDescendantEdges(nodeToAttach);\n        childEdges.forEach(e=> {\n            self.edges.push(e);\n            self.nodes.push(e.childNode);\n            e.childNode.expressionScope = null;\n        });\n\n        return nodeOrEdge;\n    }\n\n    cloneNodes(nodes) {\n        var roots = []\n        //TODO\n    }\n\n    /*shallow clone without parent and children*/\n    cloneNode(node) {\n        var clone = Utils.clone(node)\n        clone.$id = Utils.guid();\n        clone.location = Utils.clone(node.location);\n        clone.computed = Utils.clone(node.computed);\n        clone.$parent = null;\n        clone.childEdges = [];\n        return clone;\n    }\n\n    findNodeById(id) {\n        return Utils.find(this.nodes, n=>n.$id == id);\n    }\n\n    findEdgeById(id) {\n        return Utils.find(this.edges, e=>e.$id == id);\n    }\n\n    findById(id) {\n        var node = this.findNodeById(id);\n        if (node) {\n            return node;\n        }\n        return this.findEdgeById(id);\n    }\n\n    _removeNode(node) {// simply removes node from node list\n        var index = this.nodes.indexOf(node);\n        if (index > -1) {\n            this.nodes.splice(index, 1);\n        }\n    }\n\n    removeEdge(edge) {\n        var index = edge.parentNode.childEdges.indexOf(edge);\n        if (index > -1) {\n            edge.parentNode.childEdges.splice(index, 1);\n        }\n        this._removeEdge(edge);\n    }\n\n    _removeEdge(edge) { //removes edge from edge list without removing connected nodes\n        var index = this.edges.indexOf(edge);\n        if (index > -1) {\n            this.edges.splice(index, 1);\n        }\n    }\n\n    _removeNodes(nodesToRemove) {\n        this.nodes = this.nodes.filter(n=>nodesToRemove.indexOf(n) === -1);\n    }\n\n    _removeEdges(edgesToRemove) {\n        this.edges = this.edges.filter(e=>edgesToRemove.indexOf(e) === -1);\n    }\n\n    getAllDescendantEdges(node) {\n        var self = this;\n        var result = [];\n\n        node.childEdges.forEach(e=> {\n            result.push(e);\n            if (e.childNode) {\n                result.push(...self.getAllDescendantEdges(e.childNode));\n            }\n        });\n\n        return result;\n    }\n\n    getAllDescendantNodes(node) {\n        var self = this;\n        var result = [];\n\n        node.childEdges.forEach(e=> {\n            if (e.childNode) {\n                result.push(e.childNode);\n                result.push(...self.getAllDescendantNodes(e.childNode));\n            }\n        });\n\n        return result;\n    }\n\n    getAllNodesInSubtree(node) {\n        var descendants = this.getAllDescendantNodes(node);\n        descendants.unshift(node);\n        return descendants;\n    }\n\n    isUndoAvailable() {\n        return !!this.undoStack.length\n    }\n\n    isRedoAvailable() {\n        return !!this.redoStack.length\n    }\n\n    createStateSnapshot(revertConf){\n        return {\n            revertConf: revertConf,\n            nodes: Utils.cloneDeep(this.nodes),\n            edges: Utils.cloneDeep(this.edges),\n            texts: Utils.cloneDeep(this.texts),\n            payoffNames: Utils.cloneDeep(this.payoffNames),\n            defaultCriterion1Weight: Utils.cloneDeep(this.defaultCriterion1Weight),\n            weightLowerBound: Utils.cloneDeep(this.weightLowerBound),\n            weightUpperBound: Utils.cloneDeep(this.weightUpperBound),\n            expressionScope: Utils.cloneDeep(this.expressionScope),\n            code: this.code,\n            $codeError: this.$codeError\n        }\n    }\n\n\n    saveStateFromSnapshot(state){\n        this.redoStack.length = 0;\n\n        this._pushToStack(this.undoStack, state);\n\n        this._fireUndoRedoCallback();\n\n        return this;\n    }\n\n    saveState(revertConf) {\n        this.saveStateFromSnapshot(this.createStateSnapshot(revertConf));\n        return this;\n    }\n\n    undo() {\n        var self = this;\n        var newState = this.undoStack.pop();\n        if (!newState) {\n            return;\n        }\n\n        this._pushToStack(this.redoStack, {\n            revertConf: newState.revertConf,\n            nodes: self.nodes,\n            edges: self.edges,\n            texts: self.texts,\n            payoffNames: self.payoffNames,\n            defaultCriterion1Weight: self.defaultCriterion1Weight,\n            weightLowerBound: self.weightLowerBound,\n            weightUpperBound: self.weightUpperBound,\n            expressionScope: self.expressionScope,\n            code: self.code,\n            $codeError: self.$codeError\n\n        });\n\n        this._setNewState(newState);\n\n        this._fireUndoRedoCallback();\n\n        return this;\n    }\n\n    redo() {\n        var self = this;\n        var newState = this.redoStack.pop();\n        if (!newState) {\n            return;\n        }\n\n        this._pushToStack(this.undoStack, {\n            revertConf: newState.revertConf,\n            nodes: self.nodes,\n            edges: self.edges,\n            texts: self.texts,\n            payoffNames: self.payoffNames,\n            defaultCriterion1Weight: self.defaultCriterion1Weight,\n            weightLowerBound: self.weightLowerBound,\n            weightUpperBound: self.weightUpperBound,\n            expressionScope: self.expressionScope,\n            code: self.code,\n            $codeError: self.$codeError\n        });\n\n        this._setNewState(newState, true);\n\n        this._fireUndoRedoCallback();\n\n        return this;\n    }\n\n    clear() {\n        this.nodes.length = 0;\n        this.edges.length = 0;\n        this.undoStack.length = 0;\n        this.redoStack.length = 0;\n        this.texts.length = 0;\n        this.clearExpressionScope();\n        this.code = '';\n        this.$codeError = null;\n        this.$codeDirty = false;\n\n        this.payoffNames = [];\n        this.defaultCriterion1Weight = 1;\n        this.weightLowerBound = 0;\n        this.weightUpperBound = Infinity;\n    }\n\n    clearComputedValues(){\n        this.nodes.forEach(n=>n.clearComputedValues());\n        this.edges.forEach(e=>e.clearComputedValues());\n    }\n\n    addText(text) {\n        this.texts.push(text);\n\n        this._fireTextAddedCallback(text);\n    }\n\n    removeTexts(texts) {\n        texts.forEach(t=>this.removeText(t));\n    }\n\n    removeText(text) {\n        var index = this.texts.indexOf(text);\n        if (index > -1) {\n            this.texts.splice(index, 1);\n            this._fireTextRemovedCallback(text);\n        }\n    }\n\n    clearExpressionScope() {\n        Utils.forOwn(this.expressionScope, (value, key)=> {\n            delete this.expressionScope[key];\n        });\n    }\n\n    reversePayoffs(){\n        this.payoffNames.reverse();\n        this.edges.forEach(e=>e.payoff.reverse())\n    }\n\n    _setNewState(newState, redo) {\n        var nodeById = Utils.getObjectByIdMap(newState.nodes);\n        var edgeById = Utils.getObjectByIdMap(newState.edges);\n        this.nodes = newState.nodes;\n        this.edges = newState.edges;\n        this.texts = newState.texts;\n        this.payoffNames = newState.payoffNames;\n        this.defaultCriterion1Weight = newState.defaultCriterion1Weight;\n        this.weightLowerBound = newState.weightLowerBound;\n        this.weightUpperBound = newState.weightUpperBound;\n        this.expressionScope = newState.expressionScope;\n        this.code = newState.code;\n        this.$codeError  = newState.$codeError\n\n        this.nodes.forEach(n=> {\n            for (var i = 0; i < n.childEdges.length; i++) {\n                var edge = edgeById[n.childEdges[i].$id];\n                n.childEdges[i] = edge;\n                edge.parentNode = n;\n                edge.childNode = nodeById[edge.childNode.$id];\n            }\n\n        });\n\n        if (newState.revertConf) {\n            if (!redo && newState.revertConf.onUndo) {\n                newState.revertConf.onUndo(newState.revertConf.data);\n            }\n            if (redo && newState.revertConf.onRedo) {\n                newState.revertConf.onRedo(newState.revertConf.data);\n            }\n\n\n        }\n        this.revertConf = newState.revertConf;\n    }\n\n\n    _pushToStack(stack, obj) {\n        if (stack.length >= this.maxStackSize) {\n            stack.shift();\n        }\n        stack.push(obj);\n    }\n\n    _fireUndoRedoCallback() {\n        if (!this.callbacksDisabled && this.undoRedoStateChangedCallback) {\n            this.undoRedoStateChangedCallback();\n        }\n    }\n\n    _fireNodeAddedCallback(node) {\n        if (!this.callbacksDisabled && this.nodeAddedCallback) {\n            this.nodeAddedCallback(node);\n        }\n    }\n\n    _fireNodeRemovedCallback(node) {\n        if (!this.callbacksDisabled && this.nodeRemovedCallback) {\n            this.nodeRemovedCallback(node);\n        }\n    }\n\n    _fireTextAddedCallback(text) {\n        if (!this.callbacksDisabled && this.textAddedCallback) {\n            this.textAddedCallback(text);\n        }\n    }\n\n    _fireTextRemovedCallback(text) {\n        if (!this.callbacksDisabled && this.textRemovedCallback) {\n            this.textRemovedCallback(text);\n        }\n    }\n}\n","import {ObjectWithComputedValues} from \"./object-with-computed-values\";\n\nexport class Edge extends ObjectWithComputedValues {\n    parentNode;\n    childNode;\n\n    name = '';\n    probability = undefined;\n    payoff = [0, 0];\n\n    $DISPLAY_VALUE_NAMES = ['probability', 'payoff', 'optimal'];\n\n    constructor(parentNode, childNode, name, payoff, probability,) {\n        super();\n        this.parentNode = parentNode;\n        this.childNode = childNode;\n\n        if (name !== undefined) {\n            this.name = name;\n        }\n        if (probability !== undefined) {\n            this.probability = probability;\n        }\n        if (payoff !== undefined) {\n            this.payoff = payoff\n        }\n\n    }\n\n    setName(name) {\n        this.name = name;\n        return this;\n    }\n\n    setProbability(probability) {\n        this.probability = probability;\n        return this;\n    }\n\n    setPayoff(payoff, index = 0) {\n        this.payoff[index] = payoff;\n        return this;\n    }\n\n    computedBaseProbability(val) {\n        return this.computedValue(null, 'probability', val);\n    }\n\n    computedBasePayoff(val, index = 0) {\n        return this.computedValue(null, 'payoff[' + index + ']', val);\n    }\n\n    displayProbability(val) {\n        return this.displayValue('probability', val);\n    }\n\n    displayPayoff(val, index = 0) {\n        return this.displayValue('payoff[' + index + ']', val);\n    }\n}\n","export * from './node/node'\nexport * from './node/decision-node'\nexport * from './node/chance-node'\nexport * from './node/terminal-node'\nexport * from './edge'\nexport * from './point'\nexport * from './text'\n","import {Node} from './node'\n\nexport class ChanceNode extends Node{\n\n    static $TYPE = 'chance';\n\n    constructor(location){\n        super(ChanceNode.$TYPE, location);\n    }\n}\n","import {Node} from './node'\n\nexport class DecisionNode extends Node{\n\n    static $TYPE = 'decision';\n\n    constructor(location){\n        super(DecisionNode.$TYPE, location);\n    }\n}\n","import {Point} from '../point'\nimport {ObjectWithComputedValues} from '../object-with-computed-values'\n\nexport class Node extends ObjectWithComputedValues{\n\n    type;\n    childEdges=[];\n    name='';\n\n    location; //Point\n\n    code='';\n    $codeDirty = false; // is code changed without reevaluation?\n    $codeError = null; //code evaluation errors\n\n    expressionScope=null;\n\n    folded = false; // is node folded along with its subtree\n\n    $DISPLAY_VALUE_NAMES = ['childrenPayoff', 'aggregatedPayoff', 'probabilityToEnter', 'optimal']\n\n    constructor(type, location){\n        super();\n        this.location=location;\n        if(!location){\n            this.location = new Point(0,0);\n        }\n        this.type=type;\n    }\n\n    setName(name){\n        this.name = name;\n        return this;\n    }\n\n    moveTo(x,y, withChildren){ //move to new location\n        if(withChildren){\n            var dx = x-this.location.x;\n            var dy = y-this.location.y;\n            this.childEdges.forEach(e=>e.childNode.move(dx, dy, true))\n        }\n\n        this.location.moveTo(x,y);\n        return this;\n    }\n\n    move(dx, dy, withChildren){ //move by vector\n        if(withChildren){\n            this.childEdges.forEach(e=>e.childNode.move(dx, dy, true))\n        }\n        this.location.move(dx, dy);\n        return this;\n    }\n}\n","import {Node} from './node'\n\nexport class TerminalNode extends Node{\n\n    static $TYPE = 'terminal';\n\n    constructor(location){\n        super(TerminalNode.$TYPE, location);\n    }\n}\n","import {Utils} from 'sd-utils'\n\nimport {ObjectWithIdAndEditableFields} from \"./object-with-id-and-editable-fields\";\n\nexport class ObjectWithComputedValues extends ObjectWithIdAndEditableFields{\n\n    computed={}; //computed values\n\n    /*get or set computed value*/\n    computedValue(ruleName, fieldPath, value){\n        var path = 'computed.';\n        if(ruleName){\n            path+=ruleName+'.';\n        }\n        path+=fieldPath;\n        if(value===undefined){\n            return  Utils.get(this, path, null);\n        }\n        Utils.set(this, path, value);\n        return value;\n    }\n\n    clearComputedValues(ruleName){\n        if(ruleName==undefined){\n            this.computed={};\n            return;\n        }\n        if(Utils.isArray(ruleName)){\n            ruleName.forEach(n=>{\n                this.computed[n]={};\n            });\n            return;\n        }\n        this.computed[ruleName]={};\n    }\n\n    clearDisplayValues(){\n        this.computed['$displayValues']={};\n    }\n\n    displayValue(fieldPath, value){\n        return this.computedValue(null, '$displayValues.'+fieldPath, value);\n    }\n\n    loadComputedValues(computed){\n        this.computed = Utils.cloneDeep(computed);\n    }\n}\n","import {Utils} from 'sd-utils'\n\nexport class ObjectWithIdAndEditableFields {\n\n    $id = Utils.guid(); //internal id\n    $fieldStatus={};\n\n    getFieldStatus(fieldPath){\n        if(!Utils.get(this.$fieldStatus, fieldPath, null)){\n            Utils.set(this.$fieldStatus, fieldPath, {\n                valid: {\n                    syntax: true,\n                    value: true\n                }\n            });\n        }\n        return Utils.get(this.$fieldStatus, fieldPath);\n    }\n\n    setSyntaxValidity(fieldPath, valid){\n        var fieldStatus = this.getFieldStatus(fieldPath);\n        fieldStatus.valid.syntax = valid;\n    }\n\n    setValueValidity(fieldPath, valid){\n        var fieldStatus = this.getFieldStatus(fieldPath);\n        fieldStatus.valid.value = valid;\n    }\n\n    isFieldValid(fieldPath, syntax=true, value=true){\n        var fieldStatus = this.getFieldStatus(fieldPath);\n        if(syntax && value) {\n            return fieldStatus.valid.syntax && fieldStatus.valid.value;\n        }\n        if(syntax) {\n            return fieldStatus.valid.syntax\n        }\n        return fieldStatus.valid.value;\n    }\n\n\n}\n","export class Point {\n    x;\n    y;\n    constructor(x,y){\n        if(x instanceof Point){\n            y=x.y;\n            x=x.x\n        }else if(Array.isArray(x)){\n            y=x[1];\n            x=x[0];\n        }\n        this.x=x;\n        this.y=y;\n    }\n\n    moveTo(x,y){\n        if(Array.isArray(x)){\n            y=x[1];\n            x=x[0];\n        }\n        this.x=x;\n        this.y=y;\n        return this;\n    }\n\n    move(dx,dy){ //move by vector\n        if(Array.isArray(dx)){\n            dy=dx[1];\n            dx=dx[0];\n        }\n        this.x+=dx;\n        this.y+=dy;\n        return this;\n    }\n\n}\n","import {Point} from \"./point\";\nimport {Utils} from \"sd-utils\";\nimport {ObjectWithIdAndEditableFields} from \"./object-with-id-and-editable-fields\";\n\nexport class Text extends ObjectWithIdAndEditableFields{\n\n    value='';\n    location; //Point\n\n    constructor(location, value){\n        super();\n        this.location=location;\n        if(!location){\n            this.location = new Point(0,0);\n        }\n\n        if(value) {\n            this.value = value;\n        }\n    }\n\n    moveTo(x,y){ //move to new location\n        this.location.moveTo(x,y);\n        return this;\n    }\n\n    move(dx, dy){ //move by vector\n        this.location.move(dx, dy);\n        return this;\n    }\n}\n","import * as domain from './domain'\nexport {domain}\nexport * from './data-model'\nexport * from './validation-result'\n","import {Utils} from \"sd-utils\";\n\nexport class ValidationResult{\n\n\n    errors = {};\n    warnings = {};\n    objectIdToError={};\n\n    addError(error, obj){\n        if(Utils.isString(error)){\n            error = {name: error};\n        }\n        var name = error.name;\n        var errorsByName = this.errors[name];\n        if(!errorsByName){\n            errorsByName=[];\n            this.errors[name]=errorsByName;\n        }\n        var objE = this.objectIdToError[obj.$id];\n        if(!objE){\n            objE=[];\n            this.objectIdToError[obj.$id]= objE;\n        }\n        errorsByName.push(obj);\n        objE.push(error);\n    }\n\n    addWarning(name, obj){\n        var e = this.warnings[name];\n        if(!e){\n            e=[];\n            this.warnings[name]=e;\n        }\n        e.push(obj)\n    }\n\n    isValid(){\n        return Object.getOwnPropertyNames(this.errors).length === 0\n    }\n\n    static createFromDTO(dto){\n        var v = new ValidationResult();\n        v.errors = dto.errors;\n        v.warnings = dto.warnings;\n        v.objectIdToError = dto.objectIdToError;\n        return v;\n    }\n}\n","export * from './src/index'\n"]}